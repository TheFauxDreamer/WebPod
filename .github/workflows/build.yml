name: Build libgpod

on:
  push:
    branches: [master]
    tags: ['v*']
  pull_request:
    branches: [master]
  workflow_dispatch:

jobs:
  build:
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-24.04
            python-version: '3.14'
            artifact-name: libgpod-linux-x86_64-py3.14
          - os: macos-15
            python-version: '3.14'
            artifact-name: libgpod-macos-arm64-py3.14

    runs-on: ${{ matrix.os }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install Python packages
        run: pip install mutagen

      - name: Install system dependencies (Ubuntu)
        if: startsWith(matrix.os, 'ubuntu')
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            cmake \
            pkg-config \
            swig \
            python3-dev \
            libglib2.0-dev \
            libsqlite3-dev \
            libplist-dev \
            zlib1g-dev \
            libgdk-pixbuf-2.0-dev \
            libxml2-dev

      - name: Install system dependencies (macOS)
        if: startsWith(matrix.os, 'macos')
        run: |
          brew install \
            cmake \
            pkg-config \
            swig \
            glib \
            sqlite \
            libplist \
            gdk-pixbuf \
            libxml2

      - name: Configure
        run: |
          if [[ "$RUNNER_OS" == "macOS" ]]; then
            export PKG_CONFIG_PATH="$(brew --prefix libplist)/lib/pkgconfig:$(brew --prefix glib)/lib/pkgconfig:$(brew --prefix gdk-pixbuf)/lib/pkgconfig:$(brew --prefix libxml2)/lib/pkgconfig:$(brew --prefix sqlite)/lib/pkgconfig:$PKG_CONFIG_PATH"
          fi
          cmake -B build \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_INSTALL_PREFIX=/usr/local

      - name: Build
        run: |
          if [[ "$RUNNER_OS" == "Linux" ]]; then
            cmake --build build --parallel $(nproc)
          else
            cmake --build build --parallel $(sysctl -n hw.ncpu)
          fi

      - name: Install to staging directory
        run: cmake --install build --prefix "$(pwd)/staging/usr/local"

      - name: Package artifacts
        run: |
          cp -r webpod staging/webpod
          cd staging
          tar czf ../${{ matrix.artifact-name }}.tar.gz .

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact-name }}
          path: ${{ matrix.artifact-name }}.tar.gz

      - name: Verify Python bindings
        run: |
          if [[ "$RUNNER_OS" == "Linux" ]]; then
            export LD_LIBRARY_PATH=$(pwd)/staging/usr/local/lib:$LD_LIBRARY_PATH
          else
            export DYLD_LIBRARY_PATH=$(pwd)/staging/usr/local/lib:$DYLD_LIBRARY_PATH
          fi
          PYVER=$(python -c "import sys; print(f'{sys.version_info.major}.{sys.version_info.minor}')")
          PYTHONPATH="$(pwd)/staging/usr/local/lib/python${PYVER}/site-packages"
          export PYTHONPATH
          python -c "import gpod; assert hasattr(gpod, 'Database'), 'Database class missing'; print('gpod module loaded successfully')"

  build-windows:
    runs-on: windows-latest

    defaults:
      run:
        shell: msys2 {0}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # Install native CPython BEFORE MSYS2 so we can capture its path.
      # The .pyd will be linked against this Python's DLL (python3XX.dll)
      # rather than MSYS2's libpython, so it works on end-user machines.
      - name: Set up native Python
        uses: actions/setup-python@v5
        id: setup-python
        with:
          python-version: '3.14'

      - name: Save native Python paths
        shell: pwsh
        run: |
          $pythonDir = Split-Path "${{ steps.setup-python.outputs.python-path }}"
          echo "NATIVE_PYTHON_DIR=$pythonDir" >> $env:GITHUB_ENV

      - name: Setup MSYS2
        uses: msys2/setup-msys2@v2
        with:
          msystem: MINGW64
          update: true
          install: >-
            mingw-w64-x86_64-cmake
            mingw-w64-x86_64-gcc
            mingw-w64-x86_64-glib2
            mingw-w64-x86_64-sqlite3
            mingw-w64-x86_64-libplist
            mingw-w64-x86_64-zlib
            mingw-w64-x86_64-gdk-pixbuf2
            mingw-w64-x86_64-libxml2
            mingw-w64-x86_64-swig
            mingw-w64-x86_64-python
            mingw-w64-x86_64-python-mutagen
            mingw-w64-x86_64-pkg-config
            mingw-w64-x86_64-tools
            make

      - name: Show Python versions
        run: |
          echo "MSYS2 Python: $(python --version)"
          NATIVE_DIR=$(cygpath "$NATIVE_PYTHON_DIR")
          echo "Native Python: $("$NATIVE_DIR/python.exe" --version)"

      - name: Create native Python import library for MinGW
        run: |
          NATIVE_DIR=$(cygpath "$NATIVE_PYTHON_DIR")
          PYVER=$("$NATIVE_DIR/python.exe" -c "import sys; print(f'{sys.version_info.major}{sys.version_info.minor}')")
          echo "Creating import library for python${PYVER}.dll"
          gendef "$NATIVE_DIR/python${PYVER}.dll"
          dlltool -D "python${PYVER}.dll" -d "python${PYVER}.def" -l libpython-native.a
          echo "NATIVE_PYTHON_IMPORTLIB=$(pwd)/libpython-native.a" >> "$GITHUB_ENV"

      - name: Configure
        run: |
          cmake -B build \
            -G "MSYS Makefiles" \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_INSTALL_PREFIX=/mingw64 \
            -DPython3_EXECUTABLE=$(which python) \
            -DNATIVE_PYTHON_LIBRARY="$NATIVE_PYTHON_IMPORTLIB"

      - name: Build
        run: cmake --build build --parallel $(nproc)

      - name: Install to staging directory
        run: cmake --install build --prefix "$(pwd)/staging/mingw64"

      - name: Bundle MINGW64 runtime DLLs
        run: |
          PYVER=$(python -c "import sys; print(f'{sys.version_info.major}.{sys.version_info.minor}')")
          SITE="$(pwd)/staging/mingw64/lib/python${PYVER}/site-packages"
          BINDIR="$(pwd)/staging/mingw64/bin"
          mkdir -p "$BINDIR"

          # grep returns exit 1 on no matches, which kills the step under
          # set -eo pipefail (GitHub Actions default).  Wrap in a subshell
          # with || true so empty results are safe.
          # Exclude libpython â€” the .pyd is linked against native CPython's
          # python3XX.dll which is already loaded in the user's process.
          collect_deps() {
            (ldd "$1" 2>/dev/null | grep '=> /mingw64/bin/' | grep -v 'libpython' | awk '{print $3}' | sort -u) || true
          }

          # Seed with dependencies from _gpod.pyd and libgpod.dll
          TO_CHECK=$(collect_deps "$SITE/gpod/_gpod.pyd")
          for dll_path in "$BINDIR"/libgpod*.dll; do
            [ -f "$dll_path" ] && TO_CHECK="$TO_CHECK"$'\n'"$(collect_deps "$dll_path")"
          done
          TO_CHECK=$(echo "$TO_CHECK" | sort -u | (grep -v '^$' || true))

          # Recursively resolve transitive dependencies
          COPIED=""
          while [ -n "$TO_CHECK" ]; do
            NEW_DEPS=""
            for dll in $TO_CHECK; do
              dll_name=$(basename "$dll")
              if [ ! -f "$BINDIR/$dll_name" ]; then
                cp "$dll" "$BINDIR/"
                COPIED="$COPIED $dll_name"
                NEW_DEPS="$NEW_DEPS"$'\n'"$(collect_deps "$dll")"
              fi
            done
            TO_CHECK=$(echo "$NEW_DEPS" | sort -u | (grep -v '^$' || true))
          done

          echo "=== Bundled $(echo $COPIED | wc -w) MINGW64 DLLs ==="
          for d in $COPIED; do echo "  $d"; done
          echo "=== staging/mingw64/bin/ contents ==="
          ls "$BINDIR/"*.dll 2>/dev/null || echo "(none)"

      - name: Copy libgpod DLL into gpod package
        run: |
          PYVER=$(python -c "import sys; print(f'{sys.version_info.major}.{sys.version_info.minor}')")
          SITE="$(pwd)/staging/mingw64/lib/python${PYVER}/site-packages"
          cp staging/mingw64/bin/libgpod*.dll "$SITE/gpod/" 2>/dev/null || \
            cp staging/mingw64/lib/libgpod*.dll "$SITE/gpod/" 2>/dev/null || true

      - name: Package artifacts
        run: |
          cp -r webpod staging/webpod
          cd staging
          tar czf ../libgpod-windows-x86_64-py3.14.tar.gz .

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: libgpod-windows-x86_64-py3.14
          path: libgpod-windows-x86_64-py3.14.tar.gz

      - name: Verify Python bindings
        run: |
          PYVER=$(python -c "import sys; print(f'{sys.version_info.major}.{sys.version_info.minor}')")
          SITE="$(pwd)/staging/mingw64/lib/python${PYVER}/site-packages"
          BINDIR="$(pwd)/staging/mingw64/bin"
          echo "=== gpod package contents ==="
          ls -la "$SITE/gpod/"
          echo "=== _gpod.pyd dependencies ==="
          ldd "$SITE/gpod/_gpod.pyd" || true
          echo "=== Checking all MINGW64 deps are bundled ==="
          MISSING=""
          for dll in $( (ldd "$SITE/gpod/_gpod.pyd" 2>/dev/null | grep '=> /mingw64/bin/' | awk '{print $1}') || true); do
            if [ ! -f "$BINDIR/$dll" ] && [ ! -f "$SITE/gpod/$dll" ]; then
              MISSING="$MISSING $dll"
            fi
          done
          if [ -n "$MISSING" ]; then
            echo "ERROR: Missing bundled DLLs:$MISSING"
            exit 1
          else
            echo "All MINGW64 DLL dependencies are bundled."
          fi
          export PYTHONPATH="$SITE"
          python -c "import gpod; assert hasattr(gpod, 'Database'), 'Database class missing'; print('gpod module loaded successfully')"

  release:
    needs: [build, build-windows]
    if: startsWith(github.ref, 'refs/tags/v') && always()
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
        continue-on-error: true

      - name: Check for artifacts
        id: check_artifacts
        run: |
          if [ -d "artifacts" ] && [ -n "$(find artifacts -name '*.tar.gz' -type f)" ]; then
            echo "has_artifacts=true" >> $GITHUB_OUTPUT
            echo "Found artifacts:"
            find artifacts -name '*.tar.gz' -type f
          else
            echo "has_artifacts=false" >> $GITHUB_OUTPUT
            echo "No artifacts found"
          fi

      - name: Create GitHub Release
        if: steps.check_artifacts.outputs.has_artifacts == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
          GH_REPO: ${{ github.repository }}
        run: |
          TAG="${GITHUB_REF#refs/tags/}"

          # Check if release exists and has empty notes - if so, delete it
          if gh release view "$TAG" &>/dev/null; then
            NOTES=$(gh release view "$TAG" --json body -q '.body')
            if [ -z "$NOTES" ]; then
              echo "Existing release has empty notes, replacing it..."
              gh release delete "$TAG" --yes
            else
              echo "Existing release has notes, not replacing. Failing."
              exit 1
            fi
          fi

          # Get commit message from the tagged commit
          COMMIT_MSG=$(git tag -l --format='%(contents)' "$TAG" 2>/dev/null || true)
          if [ -z "$COMMIT_MSG" ]; then
            COMMIT_MSG=$(git log -1 --format='%B' "$TAG" 2>/dev/null || true)
          fi

          # Write release notes to file
          echo "$COMMIT_MSG" > release_notes.md
          cat >> release_notes.md << 'NOTES_EOF'

          ___

          See the [README](../../blob/master/README.md) for installation instructions.

          **Downloads:**
          NOTES_EOF

          # List available artifacts
          echo "" >> release_notes.md
          for file in $(find artifacts -name '*.tar.gz' -type f | sort); do
            filename=$(basename "$file")
            case "$filename" in
              *windows*) platform="Windows" ;;
              *macos-arm64*) platform="macOS Apple Silicon" ;;
              *linux*) platform="Linux" ;;
              *) platform="Other" ;;
            esac
            echo "- $platform: \`$filename\`" >> release_notes.md
          done

          # Collect all tarballs and create release
          FILES=$(find artifacts -name '*.tar.gz' -type f)
          gh release create "$TAG" \
            --title "WebPod $TAG" \
            --notes-file release_notes.md \
            $FILES

      - name: Release failed - no artifacts
        if: steps.check_artifacts.outputs.has_artifacts == 'false'
        run: |
          echo "::error::All builds failed - no artifacts to release"
          exit 1
