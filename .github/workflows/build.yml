name: Build libgpod

on:
  push:
    branches: [master]
    tags: ['v*']
  pull_request:
    branches: [master]
  workflow_dispatch:

jobs:
  build:
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-24.04
            python-version: '3.14'
            artifact-name: libgpod-linux-x86_64-py3.14
          - os: macos-15
            python-version: '3.14'
            artifact-name: libgpod-macos-arm64-py3.14

    runs-on: ${{ matrix.os }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install Python packages
        run: pip install mutagen

      - name: Install system dependencies (Ubuntu)
        if: startsWith(matrix.os, 'ubuntu')
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            cmake \
            pkg-config \
            swig \
            python3-dev \
            libglib2.0-dev \
            libsqlite3-dev \
            libplist-dev \
            zlib1g-dev \
            libgdk-pixbuf-2.0-dev \
            libxml2-dev

      - name: Install system dependencies (macOS)
        if: startsWith(matrix.os, 'macos')
        run: |
          brew install \
            cmake \
            pkg-config \
            swig \
            glib \
            sqlite \
            libplist \
            gdk-pixbuf \
            libxml2

      - name: Configure
        run: |
          if [[ "$RUNNER_OS" == "macOS" ]]; then
            export PKG_CONFIG_PATH="$(brew --prefix libplist)/lib/pkgconfig:$(brew --prefix glib)/lib/pkgconfig:$(brew --prefix gdk-pixbuf)/lib/pkgconfig:$(brew --prefix libxml2)/lib/pkgconfig:$(brew --prefix sqlite)/lib/pkgconfig:$PKG_CONFIG_PATH"
          fi
          cmake -B build \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_INSTALL_PREFIX=/usr/local

      - name: Build
        run: |
          if [[ "$RUNNER_OS" == "Linux" ]]; then
            cmake --build build --parallel $(nproc)
          else
            cmake --build build --parallel $(sysctl -n hw.ncpu)
          fi

      - name: Install to staging directory
        run: cmake --install build --prefix "$(pwd)/staging/usr/local"

      - name: Package artifacts
        run: |
          cp -r webpod staging/webpod
          cd staging
          tar czf ../${{ matrix.artifact-name }}.tar.gz .

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact-name }}
          path: ${{ matrix.artifact-name }}.tar.gz

      - name: Verify Python bindings
        run: |
          if [[ "$RUNNER_OS" == "Linux" ]]; then
            export LD_LIBRARY_PATH=$(pwd)/staging/usr/local/lib:$LD_LIBRARY_PATH
          else
            export DYLD_LIBRARY_PATH=$(pwd)/staging/usr/local/lib:$DYLD_LIBRARY_PATH
          fi
          PYVER=$(python -c "import sys; print(f'{sys.version_info.major}.{sys.version_info.minor}')")
          PYTHONPATH="$(pwd)/staging/usr/local/lib/python${PYVER}/site-packages"
          export PYTHONPATH
          python -c "import gpod; assert hasattr(gpod, 'Database'), 'Database class missing'; print('gpod module loaded successfully')"

  build-windows:
    runs-on: windows-latest

    defaults:
      run:
        shell: msys2 {0}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup MSYS2
        uses: msys2/setup-msys2@v2
        with:
          msystem: MINGW64
          update: true
          install: >-
            mingw-w64-x86_64-cmake
            mingw-w64-x86_64-gcc
            mingw-w64-x86_64-glib2
            mingw-w64-x86_64-sqlite3
            mingw-w64-x86_64-libplist
            mingw-w64-x86_64-zlib
            mingw-w64-x86_64-gdk-pixbuf2
            mingw-w64-x86_64-libxml2
            mingw-w64-x86_64-swig
            mingw-w64-x86_64-python
            mingw-w64-x86_64-python-mutagen
            mingw-w64-x86_64-pkg-config
            make

      - name: Show MSYS2 Python version
        run: python --version

      - name: Configure
        run: |
          cmake -B build \
            -G "MSYS Makefiles" \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_INSTALL_PREFIX=/mingw64 \
            -DPython3_EXECUTABLE=$(which python)

      - name: Build
        run: cmake --build build --parallel $(nproc)

      - name: Install to staging directory
        run: cmake --install build --prefix "$(pwd)/staging/mingw64"

      - name: Package artifacts
        run: |
          cp -r webpod staging/webpod
          cd staging
          tar czf ../libgpod-windows-x86_64-py3.14.tar.gz .

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: libgpod-windows-x86_64-py3.14
          path: libgpod-windows-x86_64-py3.14.tar.gz

      - name: Verify Python bindings
        run: |
          PYVER=$(python -c "import sys; print(f'{sys.version_info.major}.{sys.version_info.minor}')")
          SITE="$(pwd)/staging/mingw64/lib/python${PYVER}/site-packages"
          # Copy libgpod DLL next to _gpod.pyd so Windows can find it
          cp staging/mingw64/bin/libgpod*.dll "$SITE/gpod/" 2>/dev/null || cp staging/mingw64/lib/libgpod*.dll "$SITE/gpod/" 2>/dev/null || true
          echo "=== gpod package contents ==="
          ls -la "$SITE/gpod/"
          echo "=== binary format ==="
          file "$SITE/gpod/_gpod.pyd" || true
          file "$SITE/gpod/libgpod.dll" || true
          echo "=== _gpod.pyd dependencies ==="
          ldd "$SITE/gpod/_gpod.pyd" || true
          export PYTHONPATH="$SITE"
          python -c "import gpod; assert hasattr(gpod, 'Database'), 'Database class missing'; print('gpod module loaded successfully')"

  release:
    needs: [build, build-windows]
    if: startsWith(github.ref, 'refs/tags/v') && always()
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
        continue-on-error: true

      - name: Check for artifacts
        id: check_artifacts
        run: |
          if [ -d "artifacts" ] && [ -n "$(find artifacts -name '*.tar.gz' -type f)" ]; then
            echo "has_artifacts=true" >> $GITHUB_OUTPUT
            echo "Found artifacts:"
            find artifacts -name '*.tar.gz' -type f
          else
            echo "has_artifacts=false" >> $GITHUB_OUTPUT
            echo "No artifacts found"
          fi

      - name: Create GitHub Release
        if: steps.check_artifacts.outputs.has_artifacts == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
          GH_REPO: ${{ github.repository }}
        run: |
          TAG="${GITHUB_REF#refs/tags/}"

          # Check if release exists and has empty notes - if so, delete it
          if gh release view "$TAG" &>/dev/null; then
            NOTES=$(gh release view "$TAG" --json body -q '.body')
            if [ -z "$NOTES" ]; then
              echo "Existing release has empty notes, replacing it..."
              gh release delete "$TAG" --yes
            else
              echo "Existing release has notes, not replacing. Failing."
              exit 1
            fi
          fi

          # Get commit message from the tagged commit
          COMMIT_MSG=$(git tag -l --format='%(contents)' "$TAG" 2>/dev/null || true)
          if [ -z "$COMMIT_MSG" ]; then
            COMMIT_MSG=$(git log -1 --format='%B' "$TAG" 2>/dev/null || true)
          fi

          # Write release notes to file
          echo "$COMMIT_MSG" > release_notes.md
          cat >> release_notes.md << 'NOTES_EOF'

          ___

          See the [README](../../blob/master/README.md) for installation instructions.

          **Downloads:**
          NOTES_EOF

          # List available artifacts
          echo "" >> release_notes.md
          for file in $(find artifacts -name '*.tar.gz' -type f | sort); do
            filename=$(basename "$file")
            case "$filename" in
              *windows*) platform="Windows" ;;
              *macos-arm64*) platform="macOS Apple Silicon" ;;
              *linux*) platform="Linux" ;;
              *) platform="Other" ;;
            esac
            echo "- $platform: \`$filename\`" >> release_notes.md
          done

          # Collect all tarballs and create release
          FILES=$(find artifacts -name '*.tar.gz' -type f)
          gh release create "$TAG" \
            --title "WebPod $TAG" \
            --notes-file release_notes.md \
            $FILES

      - name: Release failed - no artifacts
        if: steps.check_artifacts.outputs.has_artifacts == 'false'
        run: |
          echo "::error::All builds failed - no artifacts to release"
          exit 1
